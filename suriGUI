#!/usr/bin/env bash
# coder: ro0t

set -o nounset      # Exit on undefined variable
set -o errexit      # Exit on non-zero status
set -o pipefail     # Pipe return exit status

trap 'echo [FATAL] "$BASH_COMMAND" failed with error code $?' ERR
trap exitSuriGUI EXIT SIGUSR1 SIGUSR2

# too many bug
# let's find them all
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# GLOBAL VARIABLES
# INFO
export _PROJECT_NAME="suriGUI"
export _PROJECT_DESCRIPTION="GUI for Suricata"
export _PROJECT_VER="0.2.220822"

echo -e \
"####################
#     $_PROJECT_NAME      #
# $_PROJECT_DESCRIPTION #
# build $_PROJECT_VER #
####################"


#
# DIRs
# todo: check if chown is not more needed since there is chown in suricata service (log directory was problem)
export _PROJECT_DIR_MAIN="/opt/suriGUI"     && sudo chown user:user "$_PROJECT_DIR_MAIN" -R
export _PROJECT_DIR_BACKUP="$_PROJECT_DIR_MAIN/backup"
export _PROJECT_DIR_CONF="$_PROJECT_DIR_MAIN/conf"
export _PROJECT_DIR_LOG="$_PROJECT_DIR_MAIN/log/$(date +'%Y-%m-%d')"
export _PROJECT_DIR_RES="$_PROJECT_DIR_MAIN/res"
export _PROJECT_DIR_TMP="$_PROJECT_DIR_MAIN/tmp"
export _PROJECT_DIR_SURICATA="$_PROJECT_DIR_CONF/suricata"

_PROJECT_DB_DIRS=( "$_PROJECT_DIR_MAIN"
                   "$_PROJECT_DIR_CONF"
                   "$_PROJECT_DIR_RES"
                   "$_PROJECT_DIR_LOG"
                   "$_PROJECT_DIR_TMP"
                   "$_PROJECT_DIR_SURICATA" )


#
# FILEs
export _PROJECT_FILE_CONFIG_NEW="$_PROJECT_DIR_CONF/suriGUI.yaml"             # suriGUI config file
export _PROJECT_FILE_CUSTOM_RULES="$_PROJECT_DIR_CONF/suriGUI.rules"          # Custom suricata rules
export _PROJECT_FILE_IGNORED_SIDS="$_PROJECT_DIR_CONF/ignore.list"            # Ignored SID list
export _PROJECT_FILE_SPAM="$_PROJECT_DIR_TMP/spam.tmp"                        # suriGUI-notify spam list
export _PROJECT_FILE_SURICATA_CONFIG="$_PROJECT_DIR_SURICATA/suricata.yaml"   # Suricata config file
export _PROJECT_FILE_SURICATA_RULES="$_PROJECT_DIR_SURICATA/suricata.rules"   # Default suricata rules
export _PROJECT_FILE_SURICATA_RULES_TIMESTAMP="$_PROJECT_DIR_SURICATA/suricata.rules.timestamp"   # Update timestamp
export _PROJECT_FILE_LOG="$_PROJECT_DIR_LOG/suriGUI.log"                      # suriGUI log file
export _SURICATA_FILE_LOG="$_PROJECT_DIR_LOG/eve.json"                        # Suricata log file

_PROJECT_DB_FILES=( "$_PROJECT_FILE_CONFIG_NEW"
                    "$_PROJECT_FILE_CUSTOM_RULES"
                    "$_PROJECT_FILE_LOG"
                    "$_SURICATA_FILE_LOG"
                    "$_PROJECT_FILE_SURICATA_RULES"
                    "$_PROJECT_FILE_IGNORED_SIDS"
                    "$_PROJECT_FILE_SPAM"
                    "$_PROJECT_FILE_SURICATA_CONFIG" )


#
# PIPEs
export _PROJECT_PIPE_MAIN="$_PROJECT_DIR_TMP/suriGUI.pipe"
export _PROJECT_PIPE_SID_IGNORE="$_PROJECT_DIR_TMP/settings-ignore-sid.pipe"
export _PROJECT_PIPE_SID_CUSTOM="$_PROJECT_DIR_TMP/settings-custom-sid.pipe"

_PROJECT_DB_PIPES=( "$_PROJECT_PIPE_MAIN"
                    "$_PROJECT_PIPE_SID_IGNORE"
                    "$_PROJECT_PIPE_SID_CUSTOM" )


#
# ICONs
export _PROJECT_ICON_MAIN="$_PROJECT_DIR_RES/suriGUI.png"
export _PROJECT_ICON_INACTIVE="$_PROJECT_DIR_RES/icons/inactive.png"
export _PROJECT_ICON_ACTIVE="$_PROJECT_DIR_RES/icons/active.png"
export _PROJECT_ICON_ALERT="$_PROJECT_DIR_RES/icons/alert.png"

_PROJECT_DB_ICONS=( "$_PROJECT_ICON_MAIN"
                    "$_PROJECT_ICON_INACTIVE"
                    "$_PROJECT_ICON_ALERT"
                    "$_PROJECT_ICON_ACTIVE" )


#
# PIDs
export _PROJECT_PID_MAIN="$_PROJECT_DIR_TMP/suriGUI.pid"
export PROJECT_PID_NOTIFY="$_PROJECT_DIR_TMP/suriGUI-notify.pid"


#
# REQs
_PROJECT_DB_REQS=( "libnetfilter-queue-dev"
                   "suricata"
                   "jq"
                   "yad" )


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# todo: bug found: menu is displayed on every second start ???
# maybe not closing pipes causes this
# try to investigate
function exitSuriGUI()
# Trap any exit signal and execute this function
# Remove unnecessary files
{
  echo "exiting ..."
  stopNotifyDaemon

  # Cleaning temp files
  find "$_PROJECT_DIR_TMP" -type f -name "*.pipe" -delete &>/dev/null
  find "$_PROJECT_DIR_TMP" -type f -name "*.tmp" -delete &>/dev/null
  find "$_PROJECT_DIR_TMP" -type f -name "*.tab" -delete &>/dev/null

  # close pipes just to be sure
#  exec 3<&-
#  exec 4<&-
#  exec 5<&-

#  exec 3<>/tmp/some-file
#  [[ -e /dev/fd/3 ]] && echo 'FD is open' || echo 'FD is closed'
#  exec 3<&- ; exec 3>&-
#  [[ -e /dev/fd/3 ]] && echo 'FD is open' || echo 'FD is closed'
#https://catonmat.net/bash-one-liners-explained-part-three

  case "${CONF_suricata_log_enable:-}" in
    "TRUE")  cleanLog old  ;;
    "FALSE") cleanLog all  ;;
    *) echo "[ERROR] Log not touched.."  ;;
  esac

  echo "Exit 0"
  exit 0
}


function d3bug()
# Print output messages, function names, errors
# Usage: d3bug info|error "Lorem ipsum dolor sit amet"
# TODO: do better log output
# TODO: add verbosity and no output, error only
{
  local type="${1:-}"
  local msg="${2:-}"
  local timeStamp="$(date +'%Y-%m-%d %H:%M:%S')"
  local verbosity="${CONF_global_log_verbosity:-normal}"


  if [[ ! -e "$_PROJECT_FILE_LOG" ]]
  then
    if ! mkdir -p "${_PROJECT_FILE_LOG%/*}" && touch "$_PROJECT_FILE_LOG"
    then
      echo "[FATAL] Can not write to log file. Exit 1"
      exit 1
    fi
  fi

  local message="$timeStamp  [$type]  function: ${FUNCNAME[1]}  $msg"



  case "$type" in
    ok)      echo "$timeStamp [NOTICE]  $message" | tee -a "$_PROJECT_FILE_LOG" ;;
    error)   echo "$timeStamp [ERROR]   $message" | tee -a "$_PROJECT_FILE_LOG" ;;
    info)    echo "$timeStamp [INFO]    $message" | tee -a "$_PROJECT_FILE_LOG" ;;
    warning) echo "$timeStamp [WARNING] $message" | tee -a "$_PROJECT_FILE_LOG" ;;
    *)       echo "$timeStamp [INFO]    $message" | tee -a "$_PROJECT_FILE_LOG" ;;
  esac

  #TRACE level: this is a code smell if used in production. This should be used during development to track bugs, but never committed to your VCS.
  #DEBUG level: log at this level about anything that happens in the program. This is mostly used during debugging, and I’d advocate trimming down the number of debug statement before entering the production stage, so that only the most meaningful entries are left, and can be activated during troubleshooting.
  #INFO level: log at this level all actions that are user-driven, or system specific (ie regularly scheduled operations…)
  #NOTICE level: this will certainly be the level at which the program will run when in production. Log at this level all the notable events that are not considered an error.
  #WARN level: log at this level all events that could potentially become an error. For instance if one database call took more than a predefined time, or if an in-memory cache is near capacity. This will allow proper automated alerting, and during troubleshooting will allow to better understand how the system was behaving before the failure.
  #ERROR level: log every error condition at this level. That can be API calls that return errors or internal error conditions.
  #FATAL level: too bad, it’s doomsday. Use this very scarcely, this shouldn't happen a lot in a real program. Usually logging at this level signifies the end of the program. For instance, if a network daemon can’t bind a network socket, log at this level and exit is the only sensible thing to do.
}


function cleanLog()
# Clean old log files
# Usage: cleanLog all|old
# TODO: detect old directory based on variable, remove old directories
{
  local reason=${1:-*}
  local interval="${CONF_suricata_log_old_interval:-}"

  case "$reason" in
    "all")
      echo "Log is disabled. Removing all files..."
#      sudo rm "$_PROJECT_DIR_LOG" -R
    ;;
    "old")
#      for dir in $_PROJECT_DIR_LOG/
#      do
#        if ! find . -type d -mtime +"$interval"
#        then
#          echo "old dir: $dir"
#        fi
#      done
      :
    ;;
    *) echo "Log not touched"      ;;
  esac
}


#function readConfigFile()
## Read suriGUI.conf and export all variables to yad
## Yad is not working if export is not done
## TODO: remove and replace with suriGUI.yaml
#{
#  d3bug
#  local config="${1:-*}"
#
#  source "$_PROJECT_CONFIG_FILE"
#
#  case "$config" in
##    "actionMenu")
##      actionMode="alert\!pass\!drop\!reject\!rejectsrc\!rejectdst\!rejectboth"
##      makeDefault="^"
##      export setAction=$(echo "$actionMode" | sed "s/$action/$makeDefault$action/g")
##    ;;
#    "update")
#      export configUpdate="$update"
#    ;;
##    "timeout")
##      export configTimeout="$timeout"
##    ;;
##    "duration")
##      export configDuration="$duration"
##    ;;
##    "notifications")
##      export configNotifications="$notifications"
##    ;;
##    "keep")
##      export configKeep="$keep"
##      ;;
##    "action")
##      export configAction="$action"
##      ;;
##    "notificationPositionMenu")
##      defaultPositions="Top_left\!Top_right\!Bottom_left\!Bottom_right"
##      makeDefault="^"
##      export configNotificationPositionMenu=$(echo "$defaultPositions" | sed "s/$position/$makeDefault$position/g")
##    ;;
##    "notificationPosition")
##      export configNotificationPosition="$position"
##      ;;
#    *)
#      d3bug error "wrong config lookup"
#    ;;
#  esac
#
#  d3bug info "Get config: $config"
#}

#function updateConfigFile()
## Write to suriGUI.conf and reload suricata if rule settings were changed
## NEED TO REWRITE
## will be removed and replaced with new function
#{
#  d3bug
#
#  #updateConfigFile rules "$new" "$old"
#  local component="$1"
#  local newStatus="$2"
#  local oldStatus="${3:-}"
#
#  case "$component" in
#    "rules")
#      d3bug info "Updating $component: $oldStatus -> $newStatus"
#
#      sed -i "s/\<$oldStatus\>/$newStatus/" "$_PROJECT_FILE_SURICATA_RULES"
#      # checkSuricataStatus &>/dev/null
#      #
#      # if [[ "$suricataStatus" == "active" ]]
#      # then
#      #   d3bug info "Starting Suricata reload..."
#      #   if sudo suricatasc -c reload-rules
#      #   then
#      #     #sudo systemctl reload suricata #&>/dev/null
#      #     d3bug info "Rules updated & reloaded"
#      #   else
#      #     d3bug error "Can't reload rules??"
#      #   fi
#      # else
#      #   d3bug info "Rules updated"
#      # fi
#    ;;
#    "action")
#      sed -i "s/^\(action\s*=\s*\).*\$/\1$newStatus/" "$_PROJECT_CONFIG_FILE"
#      d3bug info "Rule action: $newStatus"
#    ;;
#  esac
#}


function restartSuriGUI()
# Restart suriGUI
# Suricata should not be killed
{
  d3bug

  d3bug info "Restarting $_PROJECT_NAME"
  pkill -f "$_PROJECT_NAME" && exec "$_PROJECT_NAME"
}


# NOT FINISHED
function changeSID()
# changeSID 1234567 add|remove source|destination 1.2.3.4
# changeSID 1234567 enable|disable
{
  local SID="$1"
  local action="$2"
  local location="$3"
  local IP="$4"


  oldRule=$(grep -F "sid:$SID" $_PROJECT_FILE_SURICATA_RULES)
  if [[ -z "$oldRule" ]]
  then
    echo "Rule with SID: $SID is NOT found in file: $_PROJECT_FILE_SURICATA_RULES"
    echo "Exit 1"
    exit 1
  fi

  ruleLineNum="$(grep -n "$SID" $_PROJECT_FILE_SURICATA_RULES | head -n 1 | cut -d: -f1)"

  # get rule status
  if [[ "$oldRule" =~ ^[[:space:]]*#.* ]]
  then
    ruleStatus="inactive"
  else
    ruleStatus="active"
  fi

  # get old source/destination position in rule
  if [[ $(cut -d " " -f 5 <<< "$oldRule") == "->" ]]
  then
    sourcePos=3
    destinationPos=6
  else
    if [[ $(cut -d " " -f 6 <<< "$oldRule") == "->" ]]
    then
      sourcePos=4
      destinationPos=7
    else
      echo "Rule does NOT have standard formatting."
      echo "There is either double spaces in rule or broken comment."
      echo "Exit 1"
      exit 1
    fi
  fi

  oldSource=$(cut -d " " -f "$sourcePos" <<< "$oldRule")
  oldDestination=$(cut -d " " -f "$destinationPos" <<< "$oldRule")


  if [[ $location == "source" ]]
  then
    local oldLocation="$oldSource"
    local newLocation="$sourcePos"
  else
    local oldLocation="$oldDestination"
    local newLocation="$destinationPos"
  fi

  echo "----------------------"
  echo "- Line: $ruleLineNum"
  echo "- SID: $SID"
  echo "- Action: $action"
  echo "- Location: $location"
  echo "- IP: $IP"
  echo "- Rule: $oldRule" #| head -c 100
  echo "- Status: $ruleStatus"
  echo "- Source: $oldSource"
  echo "- Destination: $oldDestination"
  echo "----------------------"

  case "$action" in
    "add")
      # detect if location already has IP addresses
      if grep -F "$IP" &>/dev/null <<< "$oldLocation"
      then
        echo "SID $SID already contains IP: $IP in $location"
        shift
      else
        echo "SID $SID does not contain IP: $IP in $location"

        # detect if current location is prepared for multiple addresses []
        if [[ "$oldLocation" =~ \[.*\] ]]
        then
          echo "multiple addresses found"
          oldLocation=$(awk -F'[][]' '{print $2}' <<< "$oldLocation")
        else
          echo "only one address in $location"
        fi

        newAddress="[$oldLocation,!$IP]"
        echo "newAddress: $newAddress"
        echo "new location: $newLocation"

        newRule="$(awk -v r="${newAddress}" -v pos="${newLocation}" '{$pos=r}1' <<< "$oldRule")"

        echo "new location: $newRule"

        # execute change
        sed -i -e "${ruleLineNum} c\\" -e "${newRule}" ${_PROJECT_FILE_SURICATA_RULES}

      fi
    ;;
    "remove")
      :
      # Remove ip from source or destination address
    ;;
    "enable")
      :
      # comment rule
    ;;
    "disable")
      :
      # uncomment rule
    ;;
    *) exit 1 ;;

  esac
}


# NOT FINISHED
function editSID()
{
  d3bug
  local sid="${1:-}"
  local cat="${2:-}"
  local src="${3:-}"
  local dest="${4:-}"
  local action="${5:-}"

  TXT="SID: $sid   Category: $cat  Action: $action \\n"
  TXT+="Suricata has prevented $src to communicate with $dest \\n"
  TXT+="\\n"

  yad \
    --form \
    --columns=2 \
    --image="utilities-terminal" \
    --image-on-top \
    --width="600" \
    --title="Edit SID: $sid" \
    --text="$TXT" \
    \
    --field="SRC":RO "$src" \
    --field="Allow SRC to DEST":FBTN "bash -c allowSource" \
    \
    --field="DEST":RO "$dest" \
    --field="Allow DEST to SRC":FBTN "bash -c allowDestination"

}


function preventSuricataSpam()
# Prevent showing too many notifications
# For a current SID, show only 1 notification per minute
{
  d3bug

  local SID="$1"
  local SRC="$2"
  local DST="$3"

  local timeStamp="$(date +'%Y-%m-%d-%H:%M')"
  local currentLog="$timeStamp|$SID|$SRC|$DST"

  if grep -q "$currentLog" "$_PROJECT_FILE_SPAM"
  then
    d3bug error "Spam message"
    stopSpam="TRUE"
  else
    d3bug info "Not found in log"
    echo "$currentLog" >> "$_PROJECT_FILE_SPAM"
    d3bug info "Output written"
    stopSpam="FALSE"
  fi
}


function checkIgnoreSidList()
# Check if SID is on Ignore list
{
  d3bug

  local sid="$1"

  if grep -q "$sid" "$_PROJECT_FILE_IGNORED_SIDS"
  then
    d3bug error "SID: $sid is on ignore list"
    ignoreSID="TRUE"
  else
    d3bug info "SID: $sid is not on ignore list"
    ignoreSID="FALSE"
  fi
}


function send_notify()
# Show suriGUI notification when Suricata produces Alert message
# Check if SID is on Ignore list
# Check if Alert was already showed
{
  d3bug

  local type=${1:-Info}
  local cat=${2:-Category}
  local sig=${3:-Signature}
  local sid=${4:-SID}
  local src=${5:-SRC}
  local dest=${6:-DEST}
  local action=${7:-Action}


  case "$type" in
    "info")
      yad \
        --title="$_PROJECT_NAME v.$_PROJECT_VER" \
        --image="$_PROJECT_ICON_MAIN" \
        --form \
        --image-on-top \
        --button="OK" \
        --text="$cat" &
    ;;
    "alert")
      checkIgnoreSidList "$sid"
      if [[ "${ignoreSID:-}" == "FALSE" ]]
      then
        preventSuricataSpam "$sid" "$src" "$dest"
        if [[ "${stopSpam:-}" == "FALSE" ]]
        then
          case "${CONF_global_notifications_position:-}" in
            "Top left" )      pos="--posx=1 --posy=1"  ;;
            "Top right" )     pos="--posx=-1 --posy=1"  ;;
            "Bottom left" )   pos="--posx=1 --posy=-1"  ;;
            "Bottom right" )  pos="--posx=-1 --posy=-1"  ;;
            "Center" )        pos="--center"  ;;
            "Under mouse" )   pos="--mouse"  ;;
            * )               pos=""  ;;
          esac

          TXT="<b>${cat:-Potentially Bad traffic}</b>\n"
          TXT+="$(date +'%Y-%m-%d') at  $(date +'%H:%M:%S') \n"
          TXT+="<i>$sig</i>"

          actionControl="Continue blocking (default)!Don't show again (ignore)!Allow (not working yet)"

          set +o errexit # yad problem, error exit must be disabled
          yadOutput="$( yad \
            --title="suriGUI-notify" "${pos:-}" \
            --form \
            --on-top \
            --width=500 \
            --timeout="${CONF_global_notifications_duration:-30}" \
            --timeout-indicator="top" \
            --window-icon="$_PROJECT_ICON_ALERT" \
            --image="$_PROJECT_ICON_ALERT" \
            --image-on-top \
            --text="$TXT" \
            --field="SID:RO" "$sid" \
            --field="Source IP:RO" "$src" \
            --field="Destination IP:RO" "$dest" \
            --field="Action:CB" "$actionControl" \
            --button="OK":10)"

          ret=${?:-70}
          set -o errexit
          d3bug info "Return: $ret"

          case "$ret" in
            10 )
              readarray -d '|' -t array <<< "$yadOutput"
              d3bug info "Selected action: ${array[3]}"

              case "${array[3]}" in
                "Continue blocking")
                  : # Do nothing
                  #write to overview and ignore for today
                ;;

                "Don't show again")
                  if ! grep -q "$sid" "$_PROJECT_FILE_IGNORED_SIDS"
                  then
                    d3bug info "Writing SID: $sid to ignore list"
                    echo "$sid" >> $_PROJECT_FILE_IGNORED_SIDS
                  else
                    d3bug info "SID: $sid is already in ignore list"
                  fi
                ;;

                "Allow")
                  #editSID "$sid" "$cat" "$src" "$dest" #"$action"
                  :
                ;;
                *) d3bug error "Can't read action" ;;
              esac
            ;;
            # 20 )  editSID "$sid" "$cat" "$src" "$dest" "$action" ;;
            70 )  d3bug info "Timeout for notification: $sid"   ;;
            252 ) d3bug info "Escape key pressed"   ;;
            * )   echo "error"    ;;
          esac
        fi
      fi
    ;;
  esac
}


# NOT FINISHED
function updateSuriGUI()
# Not working yet
{
  d3bug

  d3bug info "Starting update"
  if [[ -d "_PROJECT_DIR_MAIN" ]]
  then
    cd "_PROJECT_DIR_MAIN"
    if git fetch
    then
      d3bug info "Update done"
      send_notify "info" "Update done. Restarting..."
      restartSuriGUI
    else
      d3bug info "No update found"
      send_notify "info" "No update found"
    fi
  fi
}


# NOT FINISHED
function deleteCustomRule()
# Remove custom suriGUI rule
# remove any modification from SID
# to be done
{
  d3bug

}


function deleteIgnoredSID()
# Remove ignored SID from Ignore list
# usage: deleteIgnoredSID SID
{
  d3bug

  local sid="$1"

  yad --image="$_PROJECT_ICON_MAIN" --image-on-top \
      --title="$_PROJECT_NAME" \
      --button="Yes" --button="No" \
      --text="Delete SID: $sid from Ignore list?" &>/dev/null

  ret=$?
  if [ $ret = 0 ]
  then
    sed -i "/$sid/d" "$_PROJECT_FILE_IGNORED_SIDS"
    d3bug info "SID: $sid removed"
    exec 4<>$_PROJECT_PIPE_SID_IGNORE echo -e "\f" >&4 &
    exec 4<>$_PROJECT_PIPE_SID_IGNORE echo -e "$(cat $_PROJECT_FILE_IGNORED_SIDS)" >&4 &
  else
    d3bug info "Nothing done"
  fi
}


function saveSettings()
# Save suriGUI settings to config file
# will be removed and replaced with new function
# TODO: replace with new yaml writer
{
  d3bug

#  readarray -d '|' -t tab1 <<< "$(cat $_PROJECT_DIR_TMP/suriGUI.tab)"
#  sed -i "s/^\(notifications\s*=\s*\).*\$/\1${tab1[0]}/" "$_PROJECT_CONFIG_FILE"
#  sed -i "s/^\(timeout\s*=\s*\).*\$/\1${tab1[3]}/" "$_PROJECT_CONFIG_FILE"
#  sed -i "s/^\(position\s*=\s*\).*\$/\1${tab1[6]}/" "$_PROJECT_CONFIG_FILE"
#
#  readarray -d '|' -t tab2 <<< "$(cat $_PROJECT_DIR_TMP/suricata.tab)"
#  sed -i "s/^\(IPS\s*=\s*\).*\$/\1${tab2[2]}/" "$_PROJECT_CONFIG_FILE"
#  sed -i "s/^\(rules\s*=\s*\).*\$/\1${tab2[3]}/" "$_PROJECT_CONFIG_FILE"
#  sed -i "s/^\(keep\s*=\s*\).*\$/\1${tab2[6]}/" "$_PROJECT_CONFIG_FILE"
#  sed -i "s/^\(log\s*=\s*\).*\$/\1${tab2[7]}/" "$_PROJECT_CONFIG_FILE"
#  sed -i "s/^\(duration\s*=\s*\).*\$/\1${tab2[8]}/" "$_PROJECT_CONFIG_FILE"
#
#  readarray -d '|' -t tab3 <<< "$(cat $_PROJECT_DIR_TMP/rules.tab)"
#  sed -i "s/^\(action\s*=\s*\).*\$/\1${tab3[0]}/" "$_PROJECT_CONFIG_FILE"
#  sed -i "s/^\(update\s*=\s*\).*\$/\1${tab3[10]}/" "$_PROJECT_CONFIG_FILE"
}


function suriGUISettings()
# suriGUI Setting Window
# PIPE 4
# PIPE 5
# suriGUI settings
# Suricata settings
# Rules settings
# Ignored SID List
# Custom Rules List - will be replaced
# Backup/Restore - Not done yet
# TODO: preview log in tab, create new tab: log
# TODO: keep log forever
{
  d3bug

  createProjectSettings
  eval export $(createProjectSettings)
  local KEY="$RANDOM"

#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#

  local descriptionSettings="  <b>$_PROJECT_NAME</b>   Version: <b>$_PROJECT_VER</b>\\n\\n"
  local descriptionSettings+="  OS: $(lsb_release -ds) on $(hostname)\\n"
  local descriptionSettings+="  Kernel: $(uname -sr)\\n\\n"
  local descriptionSettings+="  <i>$(uptime)</i>"

  local descriptionIgnoreList="List of SIDs not shown with suriGUI-notify\\n"
  local descriptionIgnoreList+="Double-click on SID to remove it."

  local positionMode="Top left\!Top right\!Bottom left\!Bottom right\!Center\!Under mouse"
  local verbosityMode="debug\!normal\!silent"
  local actionMode="alert\!pass\!drop\!reject\!rejectsrc\!rejectdst\!rejectboth"
  local makeDefault="^"

#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#

  local setPosition=$(echo "$positionMode" \
          | sed "s/$CONF_global_notifications_position/$makeDefault$CONF_global_notifications_position/g")

  local setVerbosity=$(echo "$verbosityMode" \
          | sed "s/${CONF_global_log_verbosity:-}/$makeDefault${CONF_global_log_verbosity:-}/g")

  local setAction=$(echo "$actionMode" \
          | sed "s/${CONF_suricata_action:-}/$makeDefault${CONF_suricata_action:-}/g")

  case "${CONF_suricata_action:-unknown}" in
    rejectboth) export setMode="IPS" ;;
    *)          export setMode="IDS" ;;
  esac

  declare -a ignoredSIDS="$(cat "$_PROJECT_FILE_IGNORED_SIDS")"

#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#
# SURIGUI SETTINGS - TAB 1
# TODO: auto update suriGUI

  yad \
    --plug="$KEY" \
    --form \
    --scroll \
    --tabnum=1 \
    --columns=2 \
      --field=" ":NUM         "${CONF_global_notifications_duration:-30}\!1..60\!1\!0" \
      --field=" ":CB          "${setPosition:-Center}" \
      --field="":LBL "" \
      --field=" ":NUM         "${CONF_global_update_interval:-7}\!1..120\!1\!0" \
      --field="":LBL "" \
      --field=" ":CB          "${setVerbosity:-normal}" \
      --field="Reduce output to error only":chk     "${CONF_global_log_erroronly:-FALSE}" \
      \
      --field="Show notifications (seconds)":chk    "${CONF_global_notifications_enable:-TRUE}" \
      --field="Notification position on screen":LBL "" \
      --field="":LBL "" \
      --field="Auto update suriGUI (days)":chk      "${CONF_global_update_enable:-FALSE}" \
      --field="":LBL "" \
      --field="Enable log":chk                      "${CONF_global_log_enable:-FALSE}" \
      --field="Write standard output to file":chk   "${CONF_global_file_file:-TRUE}" \
  > "$_PROJECT_DIR_TMP/suriGUI.tab" &

#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#
# SURICATA SETTINGS - TAB 2
# TODO: make help file
# TODO: manual in terminal

  yad \
    --plug="$KEY" \
    --form \
    --scroll \
    --tabnum=2 \
    --columns=2 \
      --field=" ":RO                            "$setMode" \
      --field=" ":CB                            "$setAction" \
      --field="":LBL "" \
      --field=" ":FL                            "${CONF_suricata_config:-}" \
      --field=" ":FL                            "${CONF_suricata_rules:-}" \
      --field="":LBL "" \
      --field=" ":NUM                           "${CONF_suricata_update_interval:-7}\!1..365\!1\!0" \
      --field=" ":dir                           "${CONF_suricata_log_location:-}" \
      --field=" ":NUM                           "${CONF_suricata_log_interval:-30}\!1..60\!1\!0" \
      --field="":LBL "" \
      --field="Update":fbtn "bash -c updateSuricataRules" \
      \
      --field="Suricata active mode":LBL "" \
      --field="Active rule action":LBL "" \
      --field="":LBL "" \
      --field="Suricata configuration file":LBL "" \
      --field="Suricata rule file":LBL "" \
      --field="":LBL "" \
      --field="Auto update suricata rules (days)":chk   "${CONF_suricata_update_enable:-TRUE}" \
      --field="Enable Suricata log":chk                 "${CONF_suricata_log_enable:-TRUE}" \
      --field="Remove old log (days)":chk               "${CONF_suricata_log_keep:-TRUE}" \
      --field="":LBL "" \
      --field="Download latest suricata rules":LBL "" \
    --file-filter="Yaml files (*.yaml)| *.yaml" \
    --file-filter="Config Files (*.cfg *.conf)| *.cfg *.conf" \
    --file-filter="All Files | *.*" \
  > "$_PROJECT_DIR_TMP/suricata.tab" &

#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#
# IGNORED SIDS SETTINGS - TAB 3

  exec 4<> "$_PROJECT_PIPE_SID_IGNORE"
  yad \
    --plug="$KEY" \
    --tabnum=3 \
    --list \
    --listen \
    --cycle-read \
    --text="$descriptionIgnoreList" \
    --dclick-action="bash -c 'deleteIgnoredSID %s'" \
    --column="SID" ${ignoredSIDS[@]} \
    <&4 &

#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#
# CUSTOM RULES - TAB 4
#  local customRules="$(cat $_SURICATA_CUSTOM_RULES)"
#  descCustom="List of custom Rules"
#  readarray arrayaa <<< "$(cat "$_SURICATA_CUSTOM_RULES")"
#
#  exec 5<> "$_PROJECT_PIPE_SID_CUSTOM"
#
#  yad \
#    --plug="$KEY" \
#    --tabnum=4 \
#    --list \
#    --listen \
#    --cycle-read \
#    --separator="|" \
#    --text="$descCustom" \
#    --dclick-action="bash -c 'deleteCustomRule %s'" \
#    --column="SID" --column="Status" --column="IPs" "${arrayaa[@]}" \
#    <&5 &
#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#
#  yad \
#    --plug="$KEY" \
#    --tabnum=5 \
#    --form \
#    --field="":LBL "" \
#    --field="Backup":fbtn "bash -c backupSuriGUI" \
#    &



#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#
# MAIN WINDOW - suriGUI

  yad \
    --notebook \
    --key="$KEY" \
    --center  \
    --title="suriGUI Settings" \
    --text="$descriptionSettings" \
    --auto-kill \
    --auto-close \
    --window-icon="$_PROJECT_ICON_MAIN" \
    --image="$_PROJECT_ICON_MAIN" \
    --image-on-top \
    --tab="suriGUI" --tab="Suricata" --tab="Ignored SIDs"  \
    --button="Close":1 --button="Save":0

  ret=$?
  case "$ret" in
    0 ) :
        #saveSettings
    ;;
    1 ) : ;;
    * ) exit 0  ;;
  esac

#  for tab in "$_PROJECT_DIR_TMP"/*.tab
#  do
#    rm "$tab"
#  done
}


function stopNotifyDaemon()
# Stop showing suriGUI notifications
{
  d3bug

  if [[ -f "$PROJECT_PID_NOTIFY" ]]
  then
    if ps -p "$(cat $PROJECT_PID_NOTIFY)"
    then
      d3bug info "Notifications are active. PID: $(cat $PROJECT_PID_NOTIFY)"
      if sudo kill -9 "$(cat $PROJECT_PID_NOTIFY)" #&>/dev/null
      then
        d3bug info "suriGUI-notify stopped"
        if ! rm "$PROJECT_PID_NOTIFY"
        then
          d3bug error "Can not remove PROJECT_PID_NOTIFY: $PROJECT_PID_NOTIFY"
        fi
      else
        d3bug error "Can not stop Notifications "
      fi
    else
      d3bug info "suriGUI-notify file found, but process with PID $(cat $PROJECT_PID_NOTIFY) was not"
    fi
  else
    d3bug info "suriGUI-notify PID file not found! Nothing to kill."
  fi
}

# todo: bug found: prsing is not working if file is empty
# make delay until new line is detected
function startNotifyDaemon()
# Start suriGUI notifications
# Tail Suricata eve.json file
{
  d3bug

  tail -f "$_PROJECT_DIR_LOG/eve.json" > >( \
    jq --unbuffered -r -c 'select(.event_type=="alert")' \
    | jq --unbuffered -r '@sh  "sid=\(.alert.signature_id) category=\(.alert.category) signature=\(.alert.signature) SRC=\(.src_ip) DEST=\(.dest_ip)  action=\(.alert.action)"' \
      | while read -r line; do \
        eval "$line" ; \
        send_notify "alert" "${category:-}" "${signature:-}" "$sid" "$SRC" "$DEST" "$action" ; \
      done ) &

  echo "$!" > "$PROJECT_PID_NOTIFY"

  d3bug info "Notifications started with PID: $(cat $PROJECT_PID_NOTIFY)"
}


function controlSuricataService()
# Control Suricata service with systemctl
# Usage: controlSuricataService start|stop|restart
{
  d3bug

  local action="${1:-status}"

  if sudo systemctl "$action" suricata &>/dev/null
  then
    d3bug info "$action Suricata service"
  else
    d3bug error "Can not control Suricata service. $action is not working"
  fi
}


function updateTrayMenu()
# Create suriGUI tray menu and tray icon
# usage: updateTrayMenu active|inactive
{
  d3bug

  local status="$1"

  case "$status" in
    "active")   menu="Stop Suricata service!bash -c 'controlSuricataService stop'" ;;
    "inactive") menu="Start Suricata service!bash -c 'controlSuricataService start'" ;;
    *)          menu="" ;;
  esac

  menu+="|Restart Suricata service!bash -c 'controlSuricataService restart'"
  menu+="||Settings!bash -c 'suriGUISettings'"
  menu+="||Exit!quit"

  [[ -p $_PROJECT_PIPE_MAIN ]] && exec 3<>$_PROJECT_PIPE_MAIN echo "menu:$menu" >&3 &

  d3bug info "Menu updated: $status"
  d3bug info "Menu: $menu"

  [[ -p $_PROJECT_PIPE_MAIN ]] && exec 3<>$_PROJECT_PIPE_MAIN echo "icon:$suricataStatus" >&3 &

  d3bug info "Icon updated: $status"
}


# TODO: Parser must me own file and service, second time rewriting
#idiot



function startSuriGUI()
# Start suriGUI
# PIPE 3
# Create yad tray icon
{
  d3bug

  d3bug info "Starting $_PROJECT_NAME $_PROJECT_VER"

  yad \
    --notification \
    --no-middle \
    --listen \
    --text="$_PROJECT_NAME v$_PROJECT_VER" \
    --image="$suricataStatus" \
    --separator="|" \
    --menu="Exit!quit" \
    --command="bash -c suriGUISettings" \
    <&3 &>/dev/null

  [[ -f "$_PROJECT_PID_MAIN" ]] && rm "$_PROJECT_PID_MAIN"
}


function createProjectIcons()
# Register suriGUI icon files
{
  d3bug

  for icon in "${_PROJECT_DB_ICONS[@]}"
  do
    local iconName=$(basename "$icon" | sed "s/\..*//")

    if xdg-icon-resource install --context mimetypes --size 48 "$icon" "$iconName"
    then
      d3bug info "registered $iconName"
    else
      d3bug error "Can not register icon: $iconName"
    fi
  done
}


function checkSuricataStatus()
# Check Suricata's service status
{
  d3bug

  if systemctl is-active --quiet suricata
  then
    export suricataStatus="active"
  else
    export suricataStatus="inactive"
  fi

  d3bug info "Suricata is $suricataStatus"
  updateTrayMenu "$suricataStatus"
}


# NOT FINISHED
function readCustomRules()
# Read suriGUI.rules and convert it to associative array
# Print: readCustomRules
# Set array: eval declare -A $(readCustomRules)
# Get value: echo ${RULE_1234567[status]}
{
  local file="$_PROJECT_FILE_CONFIG_NEW"
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
  sed -ne "s|^\($s\):|\1|" \
      -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
      -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $file |
  awk -F$fs '{
    indent = length($1)/2;
    vname[indent] = $2;
    for (i in vname) {if (i > indent) {delete vname[i]}}
    if (length($3) > 0) {
       vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])}
       printf("%s%s%s%s%s=\"%s\"\n", "RULE_", vn, "[", $2, "]", $3);
    }
  }'
}


# NOT FINISHED
function checkCustomRules()
# After every update, Suricata will overwrite our editing of suricata rules
# It will create a fresh rule file
# To prevent overwrite, suriGUI.rules is created to persist our editing
{
  d3bug

  # Show all custom rule settings
  # readCustomRules
  #
  # # Create associative arrays
  # eval declare -A $(readCustomRules)
  #
  # # Show value
  # SID="7654321"
  # ask="status"
  # comp="RULE_$SID[$ask]"
  # echo "output: ${!comp}"
  #
  # checkSuricataRules


  # local old=$(awk '{print $1; exit}' "$_PROJECT_FILE_SURICATA_RULES")
  # d3bug info "Suricata rule action: $old"
  # readConfigFile action
  # local new="$configAction"
  # d3bug info "suriGUI rule action: $new"
  #
  # if [[ "$old" == "$new" ]]
  # then
  #   d3bug info "Rule action match"
  # else
  #   d3bug error "Rule action mismatch"
  #   updateConfigFile rules "$new" "$old"
  # fi
}


function reloadSuricataRules()
# Reload suricata rules
{
  d3bug

  d3bug info "Starting suricata rule reload"

  if sudo suricatasc -c reload-rules #&>/dev/null
  then
    d3bug info "Rules reloaded @ $(date +'%Y-%m-%d') $(date +'%H:%M:%S')"
  else
    d3bug error "Can't reload rules!"
  fi
}


function updateSuricataRules()
# Download latest Suricata rules
# Reload Suricata if needed
{
  d3bug

  if command -v suricata-update #&>/dev/null
  then
    d3bug info "Starting update ..."

    if sudo suricata-update  --output "$_PROJECT_DIR_SURICATA" \
                        --data-dir "$_PROJECT_DIR_TMP" \
                        --no-test #&>/dev/null
    then
      sudo chown user:user "$_PROJECT_DIR_SURICATA" -R
      date +'%Y-%m-%d' > "$_PROJECT_FILE_SURICATA_RULES_TIMESTAMP"
      d3bug info "Update done @ $(date +'%Y-%m-%d %H:%M:%S')"

      reloadSuricataRules
    else
      d3bug error "Error updating Suricata rules. Exit 1"
      exit 1
    fi
  else
    d3bug error "suricata-update not installed. Exit 1"
    # TODO: maybe not exit if default file is there
    exit 1
  fi
}


function checkSuricataRules()
# Check for last update timestamp
# If rules are too old, update them
{
  d3bug

  if [[ -f "$_PROJECT_FILE_SURICATA_RULES" ]]
  then
    d3bug info "$_PROJECT_FILE_SURICATA_RULES"

    if [[ "$CONF_suricata_update_enable" == "TRUE" ]]
    then
      d3bug info "Auto-Update enabled"

      if [[ ! -f "$_PROJECT_FILE_SURICATA_RULES_TIMESTAMP" ]]
      then
        d3bug error "Timestamp not found. Updating..."
        updateSuricataRules
      else
        if [[ $(cat "$_PROJECT_FILE_SURICATA_RULES_TIMESTAMP") =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]
        then
          export lastUpdate="$((($(date +%s)-$(date +%s --date "$(cat $_PROJECT_FILE_SURICATA_RULES_TIMESTAMP)"))/(3600*24)))"
          if [[ "$lastUpdate" -gt "$CONF_suricata_update_interval" ]]
          then
            d3bug error "Rules to old. Updating..."
            updateSuricataRules
          else
            d3bug info "Rules old $lastUpdate days. No need to update. ($CONF_suricata_update_interval day interval)"
          fi
        else
          d3bug error "Rules never updated. Updating..."
          updateSuricataRules
        fi
      fi
    else
      d3bug info "Auto-Update disabled"
    fi
  else
    d3bug error "Suricata rules not found. Updating..."
    updateSuricataRules
  fi
}


function createProjectPipes()
# Create suriGUI pipes
# Pipes 3,4,5
{
  d3bug

  for pipe in "${_PROJECT_DB_PIPES[@]}"
  do
    if [[ -e $pipe ]]
    then
      if ! rm "$pipe"
      then
        d3bug error "Can't remove old pipe"
        exit 1
      fi
    else
      if ! mkfifo "$pipe"
      then
        d3bug error "Can't create pipe: $pipe"
        exit 1
      else
        d3bug info "$pipe"
      fi
    fi

  done

  if exec 3<> "$_PROJECT_PIPE_MAIN"
  then
    d3bug info "Project pipe started"
  else
    d3bug error "Can not start Project pipe. Exit 1"
    exit 1
  fi

}


function createProjectSettings()
# Read suriGui.yaml and convert it to variables
# Print: createProjectSettings "$_PROJECT_DIR_CONF/settings.yaml"
# Set variables: eval $(createProjectSettings "$_PROJECT_DIR_CONF/settings.yaml")
{
  local file="$_PROJECT_FILE_CONFIG_NEW"
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
  sed -ne "s|^\($s\):|\1|" \
      -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
      -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $file |
  awk -F$fs '{
    indent = length($1)/2;
    vname[indent] = $2;
    for (i in vname) {if (i > indent) {delete vname[i]}}
    if (length($3) > 0) {
       vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
       printf("%s%s%s=\"%s\"\n", "CONF_",vn, $2, $3);
    }
  }'
}


function checkInternetConnection()
# Check if internet connection is present
{
  d3bug

  local pingComm="$(ping -q -c 1 -W 1 1.1.1.1 >/dev/null)"

  if ($pingComm)
  then
    d3bug info "Internet connection is active"
  else
    d3bug error "No internet connection. Trying with Qubes proxy"

    export https_proxy="127.0.0.1:8082"

    if ($pingComm)
    then
      d3bug error "Internet connection not active. Exit 1"
      exit 1
    else
      d3bug info "Internet found behind Qubes Proxy"
    fi
  fi
}


function checkProjectFiles()
# Make sure that the config files are present
# If not, copy default config
# clean default file if not necessary
#only if touch is needed
{
  d3bug

  local defStorage="$_PROJECT_DIR_CONF/default"

  for file in "${_PROJECT_DB_FILES[@]}"
  do
      fileName="$(basename "$file")"
      destination="$(dirname "${file}")"
      backupFile="$defStorage/$fileName"

      if [[ ! -e "$file"  ]]
      then
        d3bug error "File not found: $file"

        if [[ -e "$backupFile" ]]
        then
          d3bug info "Backup file found"
          if cp "$backupFile" "$destination"
          then
            d3bug info "File restored: $fileName"
          else
            d3bug error "Can't copy default config file: \"$fileName\" to directory: \"$destination\""
            exit 1
          fi
        else
          if touch "$file"
          then
            d3bug info "File created: $file"
          else
            d3bug error "Can't create config file: \"$fileName\" in directory: \"$destination\""
            # TODO: try to inspect if dir is there
            # chown
            exit 1
          fi
        fi
      else
        d3bug info "$file"
      fi

  done

}


function checkProjectDirectories()
# Create project directories and set permissions to user:user
{
  d3bug

  for dir in "${_PROJECT_DB_DIRS[@]}"
  do
    if [[ ! -d "$dir" ]]
    then
      if mkdir -p "$dir"
      then
        d3bug info "Directory created: $dir"
      else
        d3bug error "Can not create directory: $dir"
        exit 1
      fi
    else
      if [[ -w "$dir" ]]
      then
        d3bug info "$dir"
      else
        d3bug error "Directory: $dir is not writable."
        if sudo chown user:user "$dir" -R
        then
          d3bug info "Directory: $dir owned"
        else
          d3bug error "Something is wrong with folder/permission"
          exit 1
        fi
      fi
    fi
  done
}


function checkProjectDependencies()
# Install project dependencies
# todo: make multi-distro
{
  d3bug

  for app in "${_PROJECT_DB_REQS[@]}"
  do
    if dpkg -s "$app"
    then
      d3bug ok "$app installed"
    else
      d3bug warning "$app not installed"

      yad --image="$_PROJECT_ICON_MAIN" \
          --image-on-top \
          --title="$_PROJECT_NAME" \
          --button="Yes" --button="No" \
          --text="$app is not installed.\nDo you want to install it now?" &>/dev/null

      ret=$?
      if [[ $ret = 0 ]]
      then
        d3bug info "Installing $app ..."
        if sudo apt-get install "$app" -y &>/dev/null
        then
          d3bug ok "$app was successfully installed"
        else
          d3bug error "Can't install: $app"
          exit 1
        fi
      else
        d3bug error "If you do not want to install $app \n then you can not use Suricata nor suriGUI."
        exit 1
      fi
    fi
  done
}



# Export functions for yad
export -f d3bug
export -f exitSuriGUI
#export -f readConfigFile
export -f saveSettings
export -f suriGUISettings
export -f deleteIgnoredSID
export -f controlSuricataService
export -f updateSuricataRules
export -f updateSuriGUI
export -f send_notify


# verbosity = silent file normal high debug
# TODO: make help function
while getopts "v:b:c:" opt
do
   case "$opt" in
      v )
        export CONF_global_log_verbosity="$OPTARG" ;;
#      b ) parameterB="$OPTARG" ;;
#      c ) parameterC="$OPTARG" ;;
      ? ) helpFunction ;; # Print helpFunction in case parameter is non-existent
   esac
done



# S T A R T   S U R I G U I
checkProjectDependencies
checkProjectDirectories
checkProjectFiles
checkInternetConnection

createProjectSettings
eval export $(createProjectSettings)
createProjectPipes
createProjectIcons

checkSuricataRules
checkCustomRules
checkSuricataStatus

startSuriGUI &



while ( ! systemctl is-active --quiet suricata )
do
  ( systemctl is-active --quiet suricata ) && break
  d3bug info "Waiting for Suricata service to start"
  sleep 5
done #&>/dev/null
d3bug info "Suricata is active"

exec 3<>$_PROJECT_PIPE_MAIN echo "visible:blink" >&3 &
while [[ ! -f "$_PROJECT_DIR_LOG/eve.json" ]]
do
  [[ -f "$_PROJECT_DIR_LOG/eve.json" ]] && break
  d3bug info "Suricata service is active but no output is generated."
  sleep 5
done #&>/dev/null
d3bug info "Log output found"


[[ "${CONF_global_notifications_enable:-}" == "TRUE" ]] && startNotifyDaemon


echo "$$" > "$_PROJECT_PID_MAIN"

while :
do
  [[ ! -f "$_PROJECT_PID_MAIN" ]] && break
  ( checkSuricataStatus ) #&>/dev/null
  sleep 5
done &>/dev/null


echo "End of script, but not IPS !!!"
